import abaqusConstants as const
import numpy as np
import os
import odbAccess
from random import choice
from string import ascii_uppercase
import abaqus

load_cases_names = [
    'Column-1',
    'Column-2',
    'Column-3',
    'Column-4',
    'Column-5',
    'Column-6',
]

def matmul(X,Y):
    rows_x, colm_x = np.shape(X)
    rows_y, colm_y = np.shape(Y)
    if not colm_x == rows_y:
        print('Error: Matrix size are not same, Matrix multiplication is not possible')
        return
    result = np.zeros((rows_x,colm_y))
    # iterate through rows of X
    for i in range(rows_x):
        # iterate through columns of Y
        for j in range(colm_y):
            # iterate through rows of Y
            for k in range(colm_x):
                result[i,j] += X[i,k] * Y[k,j]
    return result

def getFrameFieldData(frame, fieldVarString, Names, subset=None, coordinateBasis=None, volumeFrame=None):
    """
    Get field data by component
    
    Inputs:
    frame -           an OdbFrame object
    fieldVarString -  string identifying fieldOutput
    subset -          Optional, OdbSet object.  If provided, only field data
                      in members of this set will be provided.
    coordinateBasis - if supplied, field output will be transformed to this coordinate system.
    volumeFrame -     if given, IVOL data from this frame will be obtained for the element
                      labels that had field output for the requested field.
    """
    if not volumeFrame == None:
        raise NotImplementedError('Calculating volume data at results location not impelemented')
    doMises = fieldVarString.upper() == 'MISES'
    if doMises:
        fieldVarString = 'S'
    localFO = None
    try:
        if subset == None:
            localFO = frame.fieldOutputs[fieldVarString.upper()]
        else:
            localFO = frame.fieldOutputs[fieldVarString.upper()].getSubset(region=subset)
    except KeyError:
        return (None, None, None)

    if coordinateBasis and not localFO.type == const.SCALAR:
        localFO = localFO.getTransformedField(coordinateBasis)
    components = tuple(localFO.componentLabels)
    if len(components) == 0:
        components = (
         localFO.name,)
    BDBs = localFO.bulkDataBlocks
    if len(BDBs) == 0:
        return (None, None, None)
    else:
        allFieldData = None
        if doMises:
            allFieldData = np.concatenate([ a.mises for a in BDBs ])
            allFieldData = np.expand_dims(allFieldData, axis=0)
            components = ('MISES', )
        else:
            allFieldData = np.transpose(np.concatenate([ a.data for a in BDBs ]))
        if volumeFrame == None:
            return (components, allFieldData, None)
        volBDBs = []
        for i, BDB in enumerate(BDBs):
            randString = ('').join(choice(ascii_uppercase) for i in range(12))
            volElSet = BDB.instance.ElementSetFromElementLabels(name=Names.AUTOGENERATED_STRING + '_' + randString, elementLabels=BDB.elementLabels)
            thisElsetVolBDBs = volumeFrame.fieldOutputs['IVOL'].getSubset(region=volElSet).bulkDataBlocks
            if not len(thisElsetVolBDBs) == 1:
                raise RuntimeError('Volume data did not parse correctly')
            volBDBs.append(thisElsetVolBDBs[0])

        allVolumeData = np.transpose(np.concatenate([ a.data for a in volBDBs ]))
        return (
         components, allFieldData, allVolumeData[0, :])
        return
def calculateStiffnessFromVolumeAveraging(odb, pertFrames, Names,ipVolumes=None, wholeModelElset=None, referenceFrame=None, volumeFrame=None):
    """
    Calculate the 6x6 stiffness matrix for an RVE driven by a traction-applied far-field stress from a series
    of pertubation frames by performing volume averaging over the RVE's integration points.
    
    Inputs - 
        odb -             The odb object
        pertFrames -      A list of OdbFrame objects in which one component of applied stress is nonzero, 
                          all others constrained to zero in the order (11, 22, 33, 12, 13, 23)
        ipVolumes -       A numpy array of integration point volumes
        wholeModelElset - An elementSet object containing all the elements to be used in the volume averaging
                          If this is not provided, all elements will be used.
        referenceFrame -  A frame giving the reference state pertFrames are perturbed about.  It is assumed
                          that the perturbation is the value in the pert frame minus the value in this
                          reference frame.  Omitting this argument indicates that the solution in the pert
                          frames is the perturbation rather than the total solution (as is the case for
                          output in a linear perturbation step)
        volumeFrame -     Frame from which to obtain volume data for the model.  If None, will fall back
                          to referenceFrame and then to pertFrames[0]
        
    Returns -  C, ipVolumes
        C -         a 6x6 numpy array that is the stiffness matrix.
        ipVolumes - an array of all the integration point volumes
    """
    S = np.zeros((6, 6))
    scratchOdb = abaqus.session.ScratchOdb(odb)
    globalCoordSys = None
    if Names.ODB_TEMP_GLOBAL_CSYS in scratchOdb.rootAssembly.datumCsyses:
        globalCoordSys = scratchOdb.rootAssembly.datumCsyses[Names.ODB_TEMP_GLOBAL_CSYS]
    else:
        globalCoordSys = scratchOdb.rootAssembly.DatumCsysByThreePoints(name=Names.ODB_TEMP_GLOBAL_CSYS, coordSysType=const.CARTESIAN, origin=(0.0,
                                                                                                                                                         0.0,
                                                                                                                                                         0.0), point1=(1.0,
                                                                                                                                                                       0.0,
                                                                                                                                                                       0.0), point2=(0.0,
                                                                                                                                                                                     1.0,
                                                                                                                                                                                     0.0))
    if ipVolumes == None:
        volFrame = volumeFrame if volumeFrame else referenceFrame if referenceFrame else pertFrames[0]
        ipVolumes = getFrameFieldData(volFrame, 'IVOL', subset=wholeModelElset,Names=Names)[1][0]
    totalVolume = np.sum(ipVolumes)
    refStrain = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    refStress = (0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
    preferredStrainMeasures = ('NE', 'E', 'LE')
    strainMeasure = None
    for measure in preferredStrainMeasures:
        if measure in pertFrames[0].fieldOutputs:
            strainMeasure = measure
            break

    if referenceFrame:
        _, stressData, _ = getFrameFieldData(referenceFrame, 'S',Names=Names, subset=wholeModelElset, coordinateBasis=globalCoordSys)
        refStress = [ np.sum(np.multiply(ipVolumes, stressData[i])) / totalVolume for i in range(6) ]
        _, strainData, _ = getFrameFieldData(referenceFrame, strainMeasure,Names=Names, subset=wholeModelElset, coordinateBasis=globalCoordSys)
        refStrain = [ np.sum(np.multiply(ipVolumes, strainData[i])) / totalVolume for i in range(6) ]
    for i, frame in enumerate(pertFrames):
        _, stressData, _ = getFrameFieldData(frame, 'S',Names=Names, subset=wholeModelElset, coordinateBasis=globalCoordSys)
        totStress = [ np.sum(np.multiply(ipVolumes, stressData[k])) / totalVolume for k in range(6) ]
        _, strainData, _ = getFrameFieldData(frame, strainMeasure,Names=Names, subset=wholeModelElset, coordinateBasis=globalCoordSys)
        totStrain = [ np.sum(np.multiply(ipVolumes, strainData[k])) / totalVolume for k in range(6) ]
        stress = [ pert - ref for pert, ref in zip(totStress, refStress) ]
        appliedStress = stress[i]
        strain = [ pert - ref for pert, ref in zip(totStrain, refStrain) ]
        for j in range(6):
            S[(j, i)] = strain[j] / appliedStress

    return (
     np.linalg.inv(S), ipVolumes)

# Function to call
def call_different_homo_method(Names):
    ODBName=Names.JOB_NAME
    jobName = ODBName + '.odb'
    RVEOdb = odbAccess.openOdb(jobName, readOnly=True, readInternalSets=True)
    # resultsModel = abaqus.mdb.models[model_name]
    stiffnessHomogSteps = [ RVEOdb.steps[name] for name in RVEOdb.steps.keys()]
    ipVolumeFrame = RVEOdb.steps[RVEOdb.steps.keys()[0]].frames[0]
    wholeRVEElements = RVEOdb.rootAssembly.elementSets[Names.ALL_ORIGINAL_ELEMENTS_SET] if Names.ALL_ORIGINAL_ELEMENTS_SET in RVEOdb.rootAssembly.elementSets.keys() else RVEOdb.rootAssembly.elementSets[' ALL ELEMENTS']
    ipVolumes = None
    for stiffnessHomogStep in stiffnessHomogSteps:
        cMatrix, ipVolumes = calculateStiffnessFromVolumeAveraging(RVEOdb, 
                                                                   [ stiffnessHomogStep.frames[i] for i in range(1, 7) ], 
                                                                   Names=Names,
                                                                   ipVolumes=ipVolumes, 
                                                                   wholeModelElset=wholeRVEElements, 
                                                                   referenceFrame=None, 
                                                                   volumeFrame=ipVolumeFrame)
        if 'cMatrix' in locals():
            np.savetxt('%s-StiffnessMatrix.txt' % (ODBName), cMatrix, delimiter=',', fmt='%1.4e')
            return cMatrix
            


def calc_avgStress(frame,coordSys,frameIVOL,totVolume,strainMeasure):
    '''
        It takes the name of the step and will return the average stress and strain
        args:
                step_name:str
        returns:
                Avg_Stress, Avg_Strain
    '''
    stress_transformed = frame.fieldOutputs['S'].getTransformedField(datumCsys=coordSys) 
    strain_transformed = frame.fieldOutputs[strainMeasure].getTransformedField(datumCsys=coordSys) 
    stress_transformed = stress_transformed.getSubset(position=const.INTEGRATION_POINT)
    strain_transformed = strain_transformed.getSubset(position=const.INTEGRATION_POINT)
    # Stress Sum
    Tot_Stress = np.sum([stress_transformed.values[II].data * frameIVOL.values[II].data for II in range(len(stress_transformed.values))],0)
    # Strain Sum
    Tot_Strain = np.sum([strain_transformed.values[II].data * frameIVOL.values[II].data for II in range(len(strain_transformed.values))],0)
    # Calculate Average
    Avg_Stress = Tot_Stress/totVolume
    Avg_Strain = Tot_Strain/totVolume
    print('Avg_Strain: ',Avg_Strain)
    return Avg_Stress, Avg_Strain




def average_data_write(avg_stress, avg_strain,step_name):
    folder_name = 'avg_data'
    try: 
        if not os.path.exists(folder_name):
            os.makedirs(folder_name)
    except OSError:
        if not os.path.isdir(folder_name):
            raise
    file_name = os.path.join(folder_name, step_name + '_avgStress_avgStrain.txt') 
    with open(file_name,'w') as f:
        for i in range(len(avg_stress)):
            f.write(str(avg_stress[i]) + ', ' + str(avg_strain[i]))
            f.write('\n')







# Function to call
def calc_comp_C_matmul(Names):
    job_name = Names.JOB_NAME + '.odb'
    eps = np.zeros((6,6))
    sigma = np.zeros((6,6))
    # step is constant in the column direction
    odb = odbAccess.openOdb(path=job_name, readOnly=True, readInternalSets=True)
    stiffnessHomogStep = odb.steps[odb.steps.keys()[0]]
    all_frames = [ stiffnessHomogStep.frames[i] for i in range(1, 7) ]
    frameIVOL = stiffnessHomogStep.frames[0].fieldOutputs['IVOL'].getSubset(
                                        position=const.INTEGRATION_POINT)
    totVolume = sum([frameIVOL.values[i].data for i in range(len(frameIVOL.values))])
    print('IPVolume = %1.4f'%totVolume)
    
    actual_volume = 8*Names.a1 * Names.a2 * Names.a3
    print('Actual vol7ume = %1.4f'%actual_volume)
    print('abs diff vol: %1.4e' %(actual_volume- totVolume))
    coordSysName = 'global'
    coordSys = odb.rootAssembly.DatumCsysByThreePoints(name=coordSysName, 
                                                       coordSysType=const.CARTESIAN, 
                                                       origin=(0.0,0.0,0.0), 
                                                       point1=(1.0,0.0,0.0), 
                                                       point2=(0.0,1.0,0.0))
    preferredStrainMeasures = ('NE', 'E', 'LE')
    strainMeasure = None
    for measure in preferredStrainMeasures:
        if measure in stiffnessHomogStep.frames[1].fieldOutputs:
            strainMeasure = measure
            break
                                    
    for col_num, frame in enumerate(all_frames):
        avg_stress, avg_strain = calc_avgStress(frame=frame,
                                                coordSys=coordSys,
                                                frameIVOL=frameIVOL,
                                                totVolume=totVolume,
                                                strainMeasure = strainMeasure)
        average_data_write(avg_strain=avg_strain,
                           avg_stress=avg_stress,
                           step_name=load_cases_names[col_num])
        for i in range(6):
            eps[col_num, i] = avg_strain[i]
            sigma[col_num, i] = avg_stress[i]
        print("frame:", i+1, " done!")
    A_inv = np.linalg.inv(eps)
    C_mat = matmul(sigma.T, A_inv.T) 
    # print('A_inv = ',A_inv)
    column_nums = list(range(1,7))
    C = {}
    # C_mat = np.zeros((6,6))
    for i, row_num in enumerate(column_nums):
        indices = [str(row_num)+str(col_num) for col_num in column_nums]
        for idx, ind in enumerate(indices):
            C[ind] = float(C_mat[i,idx])
    
    file_name = '%s_stiffness_matrix.txt'%Names.JOB_NAME
    np.savetxt(file_name, C_mat, delimiter=',', fmt='%1.4e')
    return C, C_mat
